
当生产者做出一个产品时，消费者再消费。当消费者消费完后，生产者再生产下一个产品。


**实战开发**：

先编写产品处理者，需要管理生产线程和消费线程的状态：

```
public class ProductHandler {
    /**
     * 产品
     */
    private String product;
    /**
     * 一个标志，用于切换生产者和消费者线程。
     */
    private boolean isWait=true;

    /**
     * 生产过程： 消费者等待状态，生产者快马加鞭生产。
     * @param product
     * @throws InterruptedException
     */
    public synchronized void producer(String product) throws InterruptedException{
        if (!isWait){
            super.wait();
        }

        Thread.sleep(30);
        this.product = product;
        isWait=false;
        System.out.println(Thread.currentThread().getName()+ "生产了 "+product );
        super.notify();
    }

    /**
     * 消费过程： 生产者等待状态，消费者消费产品。
     * @throws InterruptedException
     */
    public synchronized void consumer() throws  InterruptedException {
        if (isWait){
            super.wait();
        }
        Thread.sleep(30);
        System.out.println(Thread.currentThread().getName()+ "消费了 "+product);
        isWait=true;
        super.notify();
    }
    public static ProductHandler newInstance() {
        return new ProductHandler();
    }

}
```
然后编写生产线程：
```
public class ProducerThread implements  Runnable {
    private static final  String TAG=ProducerThread.class.getSimpleName();
    private ProductHandler product;
    public ProducerThread(ProductHandler product) {
        this.product = product;
    }
    @Override
    public void run() {

        try {
            Thread.currentThread().setName(TAG);
            for (int i=0;i<10;++i){
                product.producer(createProduct(i+1));
            }
        }catch (Exception e){
         e.printStackTrace();
        }

    }
    private String createProduct(int i){
        StringBuffer stringBuffer=new StringBuffer();
        stringBuffer.append("第");
        stringBuffer.append(i);
        stringBuffer.append("个产品");
        return  stringBuffer.toString();
    }
}
```

接下来，编写消费线程：
```
public class ConsumerThread implements Runnable {
    private static final  String TAG=ConsumerThread.class.getSimpleName();
    private ProductHandler product;
    public ConsumerThread(ProductHandler product) {
        this.product = product;
    }
    @Override
    public void run() {
        try {
            Thread.currentThread().setName(TAG);
            for (int i=0;i<10;++i){
                product.consumer();
            }
        }catch (Exception e){
            e.printStackTrace();
        }

    }
}
```

客户端调用测试：
```
public class Client {
    public static void main(String[] args) {
       testDesignMode();
    }
    /**
     * 测试生产者与消费者模式：
     * <p>
     * 1. 生产者生产出一个产品
     * 2. 消费者再去消费这个产品
     * 3. 生产者需要等待，消费者消费完这个产品再去生产。
     */
    private static void testDesignMode() {
        ProductHandler product = ProductHandler.newInstance();
        new Thread(new ProducerThread(product)).start();
        new Thread(new ConsumerThread(product)).start();
    }
}
```

控制台输出结果：
```
ProducerThread生产了 第1个产品
ConsumerThread消费了 第1个产品
ProducerThread生产了 第2个产品
ConsumerThread消费了 第2个产品
ProducerThread生产了 第3个产品
ConsumerThread消费了 第3个产品
ProducerThread生产了 第4个产品
ConsumerThread消费了 第4个产品
ProducerThread生产了 第5个产品
ConsumerThread消费了 第5个产品
ProducerThread生产了 第6个产品
ConsumerThread消费了 第6个产品
ProducerThread生产了 第7个产品
ConsumerThread消费了 第7个产品
ProducerThread生产了 第8个产品
ConsumerThread消费了 第8个产品
ProducerThread生产了 第9个产品
ConsumerThread消费了 第9个产品
ProducerThread生产了 第10个产品
ConsumerThread消费了 第10个产品
```