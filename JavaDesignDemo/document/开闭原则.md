开闭原则：
>软件中的对象(类、模块、函数等)应该对于扩展是开放的，但是对于修改是封闭的。换句话说，当软件需要变化时，我们**应该尽量**通过扩展的方式来实现变化,而不是修改已有的代码来实现。

**做法**：抽象手段去扩展实现，尽量避免修改。

**实战案例**

接下来，以一个数据查询监控,支持扩展自由配置查询，回调监听的案例进一步加深理解。


先定义一个数据监听器：
```
   /**
     *  定义一个数据监听器
     */
    public interface  DataListener{
        void onChange(String content);
    }
```
定义一个数据监听通知类，用于管理监听器和发出通知：
```
private static class DataMonitor {
        private List<DataListener> listeners=new CopyOnWriteArrayList<>();
        public  void addListener(DataListener dataListener){
            this.listeners.add(dataListener);
        }
        public  void removeListener(DataListener dataListener){
           this.listeners.remove(dataListener);
        }
        public void notifyData(String content){
              for (DataListener listener:listeners){
                  listener.onChange(content);
              }
        }
        public void release(){
            listeners.clear();
        }
    }
```
抽象定义一个查询接口：
```
    /**
     * 抽象出一个数据变化查询接口
     */
    public interface QueryMonitor {
        String monitor();
    }
```
编写一个默认的查询类：
```
    /**
     * 默认的数据查询类
     */
    private static class DefaultQueryMonitor implements QueryMonitor {

        @Override
        public String monitor() {
            try {
                Thread.sleep(1000);
                return " 一秒后，监听到数据发生变化";
            } catch (Exception e) {
                e.printStackTrace();
            }

            return null;
        }
    }
```
定义一个异步线程，用于查询监听。
```
 /**
     * 定义一个专门监听数据变化的Runnable子类
     */
    public static class DefaultQueryThread implements Runnable {
        private DataMonitor dataMonitor;
        private QueryMonitor queryMonitor;

        public DefaultQueryThread(DataMonitor dataMonitor, QueryMonitor queryMonitor) {
            this.dataMonitor = dataMonitor;
            this.queryMonitor = queryMonitor;
        }

        @Override
        public void run() {
            try {
                String content = queryMonitor.monitor();
                dataMonitor.notifyData(content);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
```
定义一个数据操作者，管理异步线程，监听器，查询监听操作。
```
 /**
     * 定义一个数据操作者
     */
    private static class DataOperator {
        // 监控数据的线程池
        private ExecutorService executor;
        private DataMonitor dataCache;
        private QueryMonitor queryMonitor;

        public DataOperator() {
            this.executor = Executors.newSingleThreadExecutor();
            this.dataCache = new DataMonitor();
        }

        public DataOperator setQueryMonitor(QueryMonitor queryMonitor) {
            this.queryMonitor = queryMonitor;
            return this;
        }


        public DataOperator query(DataListener listener) {
            dataCache.addListener(listener);
            if (this.queryMonitor == null) {
                this.queryMonitor = new DefaultQueryMonitor();
            }
            // 模拟异步线程，监控数据
            executor.execute(new DefaultQueryThread(dataCache, queryMonitor));
            return this;
        }

        public void release() {
            executor.shutdown();
            dataCache.release();
        }
    }

```

测试：
```
 public static void test() {
        // 构建一个数据操作者
        DataOperator operator = new DataOperator();
        // 自定义扩展,自由配置
        operator.setQueryMonitor(new QueryMonitor() { 
                    @Override
                    public String monitor() {
                         try {
                             Thread.sleep(2*1000);
                         }catch (Exception e){
                             e.printStackTrace();
                         }
                        return "开闭原则,抽象扩展实现：2秒后，监听到数据发生改变";
                    }
                })
                .query(new DataListener() {    // 添加监听器
                    @Override
                    public void onChange(String content) {
                        System.out.println(content);
                        //不再使用，释放资源
                        operator.release();
                    }
                });
    }
```

输出结果：
```
开闭原则,抽象扩展实现：2秒后，监听到数据发生改变
```