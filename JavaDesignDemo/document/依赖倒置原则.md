依赖倒置原则：
>依赖倒置原则是一种解耦形式，使得高层次的模块不依赖低层次的模块的实现细节,依赖模块被颠倒了。

在Java中,抽象是指接口和抽象类,两者不能直接被实例化。细节就是实现接口或者继承抽象类而产生的的类。

高层模块是调用端，低层模块是具体的实现类。

依赖倒置原则在java语言中表现:模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系,其依赖关系是通过接口或者抽象类产生的。


如果类与类直接依赖细节,那么它们之间就有直接的耦合,具体实现需要发生变化时候,意味着要同事修改依赖者的代码，这限制了系统的可扩展性。

通过一个案例，进一步了解:


用户找IT公司做软件，先下单做后台系统，接着继续做客户端。

定义一个岗位的角色：
```
    /**
     * 定义一个开发色的接口
     */
    public interface Developer {

        void develop();

        int android = 1, java = 2;
    }
```
定义一个Java后台工程师角色：

```
    /**
     * 定义后台开发角色，开发后台系统
     */
    public static class JavaDeveloper implements Developer {
        @Override
        public void develop() {
            System.out.println("Java软件工程师接到需求，开发后台系统");
        }
    }
```

定义一个android工程师角色
```
    /**
     *  定义Android开发角色，做客户端
     */
    public static class AndroidDeveloper implements Developer {
        @Override
        public void develop() {
            System.out.println("Android软件工程师接到需求，开发客户端");
        }
    }
```

定义IT公司的角色，用户可以自由下单，公司会让开发工程师做对应的软件。
```
  /**
     * 定义一个it公司角色
     */
    public static class ITCompany {
         // 调用者，依赖抽象，不依赖实现类。
        private Developer developer;
        public ITCompany buyType(int type) {
            switch (type) {
                case Developer.android:
                    this.developer = new AndroidDeveloper();
                    break;
                case Developer.java:
                    this.developer = new JavaDeveloper();
                    break;
            }
            return this;
        }
        public void setDeveloper(Developer developer) {
            this.developer = developer;
        }

        public void product() {
            if (developer==null)return;
            this.developer.develop();
        }
    }
```

用户开始下单：

```
    public  static void test(){
        ITCompany company=new ITCompany();
        // 顾客先下单，后台系统
        company.buyType(Developer.java).product();
        // 顾客继续下单，做客户端
        company.buyType(Developer.android).product();
    }
```




输出结果：
```
Java软件工程师接到需求，开发后台系统
Android软件工程师接到需求，开发客户端
```