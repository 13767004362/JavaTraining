
理解：
>所有引用基类的点必须能透明的使用其子类的对象。换句话说，只要父类能够出现的地方子类就可以出现，且替换子类也不会产生任何错误或者异常。


里氏替换原则是依赖继承、多态两大特性。





通过一个实际案例，进一步了解：

1. 先定义一个抽象父类,定义开发职责和工作产出。

```Java
    /**
     *  定义一个抽象类,用于描述开发岗位，职责和工作产量。
     */
    public static abstract class Developer {
        abstract String develop();
        public void work() {
              System.out.println(develop());
        }
    }
```
2. 定义Java后台开发角色：

```Java
    /**
     * 定义Java后台开发岗位
     */
    public static  class  JavaDeveloper extends Developer{
        @Override
        String develop() {
            return "Java 后台开发，部署服务器上";
        }
    }
```

3. 定义Android客户单开发角色：

```Java
  /**
     *  定义android开发岗位
     */
    public static class  AndroidDeveloper extends Developer{
        @Override
        String develop() {
            return "Android 客户端开发,运行在Android设备上";
        }
    }
```

4. 定义公司的角色，自由切换开发岗位：

```Java
    /**
     *  定义一个公司的角色
     */
    public static class ITCompany{
        public  void work(Developer developer){
              // 自由切换子类，并不会影响
             developer.work();
        }
    }
```
输出结果：
```
Java 后台开发，部署服务器上
Android 客户端开发,运行在Android设备上
```

里氏替换原则的核心原理是抽象,抽象有依赖继承这个特性。

开闭原则往往和里氏替换原则相互共存，通过里氏替换对外扩展开发,对修改关闭的效果。