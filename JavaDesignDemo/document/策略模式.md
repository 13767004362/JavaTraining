策略模式：

>实现某一样功能可以有多种方式或者策略，不同策略之间自由相互替换，可以考虑使用策略模式。

好处：

根据实际情况动态替换不同的策略实现,扩展性,可维护性高。

使用场景：

- 同一类类型问题的多种处理方式,仅是具体行为有差异
- 需要安全封装多种同一类型的操作
- 出现同一个抽象类有多个子类，且又需要if-else或者switch-case来选择具体子类的情况。


**实际案例**：


使用不同的语言开发工作,例如java、kotlin语言。

先定义一个接口：
```
public interface WorkStrategy {
    void work();
}
```
定义一个使用java语言开发的策略：
```
public class JavaWorkStrategy implements WorkStrategy {
    @Override
    public void work() {
        System.out.println(" 使用Java语言 开发工作 ");
    }
}
```
定义一个使用kotlin语言开发的策略：
```
public class KotlinWorkStrategy implements WorkStrategy {
    @Override
    public void work() {
        System.out.println(" 使用Kotlin 语言开发工作");
    }
}
```
构建一个工作者,使用不同语言工作。
```
public class Worker1 {

    public static Worker1 create() {
        return new Worker1();
    }

    private WorkStrategy workStrategy;

    public Worker1 setWorkStrategy(WorkStrategy workStrategy) {
        this.workStrategy = workStrategy;
        return this;
    }

    public void work() {
        this.workStrategy.work();
    }
}
```
测试：
```
    /**
     * 测试策略模式
     */
    private static void testStrategy(){
       Worker1 worker= Worker1.create();
       // 自由切换不同的策略
       worker.setWorkStrategy(new JavaWorkStrategy());
       worker.work();
    }
```

输出结果：
```
 使用Java语言 开发工作 
```
